# 讲义 1 — 条件判断（Conditionals）

## 目录
- [条件判断](#条件判断)
- [if 语句](#if-语句)
- [控制流：`if`、`elif`、`else`](#控制流ifelifelse)
- [`or`](#or-1)
- [`and`](#and-1)
- [取模（Modulo）](#取模modulo)
- [编写自己的奇偶函数](#编写自己的奇偶函数)
- [更 Pythonic 的写法](#更-pythonic-的写法)
- [`match`](#match-1)
- [小结](#小结)

---

## 条件判断

- **条件判断**让程序可以*做决定*，在多条路径中选择其一。
- Python 提供一组常用比较运算符：
  - `>` 大于，`<` 小于
  - `>=` **大于等于**，`<=` **小于等于**
  - `==` **相等**（注意：单等号 `=` 是赋值；双等号 `==` 是比较）
  - `!=` **不等于**
- 比较表达式会得到布尔值 **`True`/`False`**。

---

## if 语句

```python
x = int(input("What's x? "))
y = int(input("What's y? "))

if x < y:
    print("x is less than y")
```
- `if` 语句使用 `bool （布尔值）（ True 或 False ）`来决定是否执行代码。
- `if` 后面的布尔表达式为 `True` 时，**缩进**代码块才会执行。

---

## 控制流：`if`、`elif`、`else`

- 注意你是如何提供一系列 if 语句的。首先，第一个 if 语句被求值。然后，第二个 if 语句运行其求值。最后，最后一个 if 语句运行其求值。这种决策流程称为“控制流”。
- 初版（每个条件都独立判断）：


```python
x = int(input("What's x? "))
y = int(input("What's y? "))

if x < y:
    print("x is less than y")
if x > y:
    print("x is greater than y")
if x == y:
    print("x is equal to y")
```
- 虽然您的计算机可能不会注意到我们的第一个程序和这个修改后的程序在速度方面的差异，但请考虑一下每天运行数十亿或数万亿次此类计算的在线服务器肯定会受到如此小的编码决策的影响。
  

- 使用 **`elif`** / **`else`** 只会执行**其中一个**分支，降低复杂度：

```python
x = int(input("What's x? "))
y = int(input("What's y? "))

if x < y:
    print("x is less than y")
elif x > y:
    print("x is greater than y")
else:
    print("x is equal to y")
```
- 我们可以使用 else 语句创建一个“包罗万象”的默认结果
- 请注意，通过我们的修改，该程序的相对复杂性已经降低。
---

## or

- `or` 让我们在一个或多个选项之间做出选择：

```python
x = int(input("What's x? "))
y = int(input("What's y? "))

if x < y or x > y:
    print("x is not equal to y")
else:
    print("x is equal to y")
```
- 请注意，我们的程序结果是相同的，但复杂度降低了。我们的代码效率提高了。
  

- 进一步简化：直接使用 **`!=`** 问一个问题即可：

```python
x = int(input("What's x? "))
y = int(input("What's y? "))

if x != y:
    print("x is not equal to y")
else:
    print("x is equal to y")
```
- 注意，我们完全去掉了“ or ，而是简单地问：“x 不等于 y 吗？”我们只问了一个问题。非常高效！
  

- 温馨提醒：**<mark>`==` 用于比较；`=` 用于赋值</mark>**。
- 注意， == 运算符会判断左右两边的内容是否相等。使用两个等号非常重要。如果只使用一个等号，解释器很可能会抛出错误。

```python
x = int(input("What's x? "))
y = int(input("What's y? "))

if x == y:
    print("x is equal to y")
else:
    print("x is not equal to y")
```

---

## and

- 与 `or` 类似，`and` 可用来连接多个条件。示例（评分程序 `grade.py`）：

```python
score = int(input("Score: "))

if score >= 90 and score <= 100:
    print("Grade: A")
elif score >= 80 and score < 90:
    print("Grade: B")
elif score >= 70 and score < 80:
    print("Grade: C")
elif score >= 60 and score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```

- Python 支持**链式比较**，更简洁可读：

```python
score = int(input("Score: "))

if 90 <= score <= 100:
    print("Grade: A")
elif 80 <= score < 90:
    print("Grade: B")
elif 70 <= score < 80:
    print("Grade: C")
elif 60 <= score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```
- 请注意，Python 如何允许您以一种在其他编程语言中并不常见的方式将运算符和条件链接在一起。


- 尽管如此，我们仍然可以进一步改进我们的程序：
```python
score = int(input("Score: "))

if score >= 90:
    print("Grade: A")
elif score >= 80:
    print("Grade: B")
elif score >= 70:
    print("Grade: C")
elif score >= 60:
    print("Grade: D")
else:
    print("Grade: F")
```
- 注意，通过减少提问次数，程序得到了怎样的改进。这使得我们的程序更易于阅读，并且将来更易于维护。
- 您可以在 Python 的控制流文档中了解更多信息。(https://docs.python.org/3/tutorial/controlflow.html)

---

## 取模（Modulo）

- **奇偶性（Parity）**：判断一个数是偶数还是奇数。取模运算符 **`%`** 返回余数：
- 编程中的模数 % 运算符允许人们查看两个数字是否可以整除或相除后是否有余数。


- 例如，4 % 2 的结果为零，因为它能被整除。然而，3 % 2 却不能被整除，所以结果不是零！
- 请注意我们的用户可以输入任何 1 或更大的数字来查看它是偶数还是奇数。
```python
x = int(input("What's x? "))

if x % 2 == 0:
    print("Even")
else:
    print("Odd")
```

---

## 编写自己的奇偶函数
- 正如在讲座 0 中所讨论的，您会发现创建自己的函数很有用！
- 我们可以创建自己的函数来检查一个数字是偶数还是奇数。调整代码如下：

```python
def main():
    x = int(input("What's x? "))
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    if n % 2 == 0:
        return True
    else:
        return False

main()
```
- 请注意，即使没有运算符，我们的 if 语句 is_even(x) 也能正常工作。这是因为我们的函数返回一个 bool True 或 False 给主函数。if if 只是判断 x 的 is_even 是否为真。


---

## 更 Pythonic 的写法
- 在编程的世界里，有些类型的编程本质上被称为“Pythonic”。也就是说，有些编程方法有时只在 Python 编程中出现。考虑以下对我们程序的修改：

```python
def main():
    x = int(input("What's x? "))
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    return True if n % 2 == 0 else False
    # 或者：return n % 2 == 0
```
- 请注意，我们代码中的这个 return 语句几乎就像一个英文句子。这是 Python 中独有的编码方式。
- 这行返回语句几乎像英文一样直观，十分 **Pythonic**。
- 请注意，程序将评估 n % 2 == 0 中发生的情况为 True 或 False ，然后将其返回给主函数。
---

## match

- 类似 `if/elif/else`，**`match`**（Python 3.10+）可根据具体值来运行对应分支：
- 与 if 、 elif 和 else 语句类似， match 语句可用于有条件地运行与特定值匹配的代码。


- 考虑以下程序：
```python
name = input("What's your name? ")

  if name == "Harry":
      print("Gryffindor")
  elif name == "Hermione":
      print("Gryffindor")
  elif name == "Ron": 
      print("Gryffindor")
  elif name == "Draco":
      print("Slytherin")
  else:
      print("Who?")
```
- 请注意，前三个条件语句打印相同的响应。


- 我们可以使用 or 关键字稍微改进一下这段代码：
```python
  name = input("What's your name? ")

  if name == "Harry" or name == "Hermione" or name == "Ron": 
      print("Gryffindor")
  elif name == "Draco":
      print("Slytherin")
  else:
      print("Who?")
```
- 请注意， elif 语句的数量已经减少，从而提高了代码的可读性。


- 或者，我们可以使用 match 语句将名称映射到房屋。请考虑以下代码：
```python
  name = input("What's your name? ")

  match name: 
      case "Harry":
          print("Gryffindor")
      case "Hermione":
          print("Gryffindor")
      case "Ron": 
          print("Gryffindor")
      case "Draco":
          print("Slytherin")
      case _:
          print("Who?")
```
- 注意最后一种情况中 _ 符号的使用。这将匹配任何输入，导致与 else 语句类似的行为。
- match 语句将 match 关键字后面的值与 case 关键字后面的每个值进行比较。如果匹配成功，则执行相应的缩进代码段，程序停止匹配。

``
- 我们可以改进代码：



```python
name = input("What's your name? ")

match name:
    case "Harry" | "Hermione" | "Ron":
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Who?")
```

- 竖线 **`|`** 在 `case` 中的作用类似 `or`。

---

## 小结

你现在可以使用条件语句来**提问并根据答案采取行动**：

- **条件判断**与比较运算符  
- **`if` / `elif` / `else`** 控制流  
- 逻辑运算：**`or`** 与 **`and`**  
- **取模**与奇偶判断  
- **可复用函数**与 *Pythonic* 的返回方式  
- 结构化匹配 **`match`**
