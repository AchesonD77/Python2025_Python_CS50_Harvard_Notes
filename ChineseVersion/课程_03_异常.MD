# 讲义 3 — 异常与错误处理

## 目录
- [异常（Exceptions）](#异常exceptions)
- [运行期错误（Runtime Errors）](#运行期错误runtime-errors)
- [try](#try-1)
- [else](#else-1)
- [封装：获取整数的函数](#封装获取整数的函数)
- [pass](#pass-1)
- [小结](#小结)

---

## 异常（Exceptions）

- **异常**是程序*运行期间*出现的问题，与**语法错误**不同（语法错误在运行前就会被解释器发现）。
- 在编辑器输入（故意漏掉一个引号）：

```python
print("hello, world)
```

- 运行 `python hello.py` 会得到 **SyntaxError**。这通常意味着需要重新检查是否**正确输入**了代码。
- 更多内容可参见 Python 文档中的 <mark>Errors and Exceptions</mark> 。（https://docs.python.org/3/tutorial/errors.html）

---

## 运行期错误（Runtime Errors）

- **运行期错误**源自程序运行中的**意外行为**。例如，要求输入数字，但用户输入了字母。
- 新建 `number.py`，编写：

```python
x = int(input("What's x? "))
print(f"x is {x}")
```

- `f` 前缀表示 **f-string**，可把变量 `x` 的值插入字符串中。
- 如果输入 `cat`，会看到：

```
ValueError: invalid literal for int() with base 10: 'cat'
```

- 即 <mark>int</mark> 无法把 `'cat'` 转换为整数。作为程序员，我们需要**防御性**编程以确保输入符合预期。

---

## try

- 使用 **`try` / `except`** 可以在崩溃前优雅地处理错误：

```python
try:
    x = int(input("What's x? "))
    print(f"x is {x}")
except ValueError:
    print("x is not an integer")
```
- 注意，运行此代码时，输​​入 50 会被接受。但是，输入 cat 会产生一个用户可见的错误，告诉他们为什么输入不被接受。
  

- 这仍然不是实现此代码的最佳方法。请注意，我们尝试编写两行代码。为了达到最佳效果，我们应该只 try 尽可能少的代码行，以免出现问题。请按如下方式调整您的代码：
  
- 如果把 `print` 放到 `try` 外面，则在转换失败时 `x` **不会被赋值**，会出现 **NameError**：

```python
try:
    x = int(input("What's x? "))
except ValueError:
    print("x is not an integer")

print(f"x is {x}")
```

- 解释：当 `int(...)` 失败时，对 `x` 的赋值并未发生，因此不存在 `x` 可供打印。事实上，如果你检查 x = int(input("What's x?")) 中的运算顺序（从右到左），它可能会接受一个输入错误的字符并尝试将其赋值为整数。如果失败，则永远不会对 x 进行赋值。因此，我们最后一行代码中没有 x 可打印。

---

## else

- 更好的写法是 **`try` / `except` / `else`**：

```python
try:
    x = int(input("What's x? "))
except ValueError:
    print("x is not an integer")
else:
    print(f"x is {x}")
```
- 注意，如果没有发生异常，它将运行 else 中的代码块。运行 python number.py 并提供 50 ，您会注意到结果会被打印出来。再次尝试，这次提供 cat ，您会注意到程序现在捕获了错误。
  

- 考虑改进我们的代码，请注意，我们对用户有点粗鲁。如果用户不配合，我们目前只会结束程序。考虑一下如何使用循环来提示用户输入 x ，如果他们没有再次提示，我们该怎么办！
- 还可以用循环不断**重新提示**，直到用户输入正确：

```python
while True:
    try:
        x = int(input("What's x? "))
    except ValueError:
        print("x is not an integer")
    else:
        break

print(f"x is {x}")
```
- 注意， while True 会一直循环。如果用户输入正确，我们可以跳出循环，然后打印输出。现在，如果用户输入错误，系统会再次要求用户输入。


---

## 封装：获取整数的函数

- 我们常常需要获取整数，把逻辑**封装**到函数里：

```python
def main():
    x = get_int()
    print(f"x is {x}")


def get_int():
    while True:
        try:
            x = int(input("What's x?"))
        except ValueError:
            print("x is not an integer")
        else:
            break
    return x


main()
```
- 注意，我们展现了许多很棒的特性。首先，我们抽象出了获取整数的能力。现在，整个程序可以归结为程序的前三行。
  

- 即使如此，我们仍然可以改进这个程序。思考一下你还能做些什么来改进这个程序。修改你的代码如下：

```python
def main():
    x = get_int()
    print(f"x is {x}")


def get_int():
    while True:
        try:
            x = int(input("What's x?"))
        except ValueError:
            print("x is not an integer")
        else:
            return x


main()
```
- 请注意， return 不仅会使您脱离循环，而且还会返回一个值。
  

- 进一步精简：在 `try` 内直接 `return`：
- 还可再短一些（行为一致，行数更少）：

```python
def main():
    x = get_int()
    print(f"x is {x}")


def get_int():
    while True:
        try:
            return int(input("What's x?"))
        except ValueError:
            print("x is not an integer")


main()
```
- 请注意，这与我们的上一次代码迭代执行的操作相同，只是行数更少。


---

## pass

- 有时不想每次都提示错误，只需**静默**地重新询问：

```python
def main():
    x = get_int()
    print(f"x is {x}")


def get_int():
    while True:
        try:
            return int(input("What's x? "))
        except ValueError:
            pass

main()
```
- 请注意，我们的代码仍然可以运行，但不会反复提示用户错误。在某些情况下，您需要非常清楚地向用户说明发生了哪些错误。其他时候，您可能只想再次请求用户输入。



- 再做一个小改进：让函数支持 **自定义提示**：

```python
def main():
    x = get_int("What's x? ")
    print(f"x is {x}")


def get_int(prompt):
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            pass

main()
```
- prompt 是函数 get_int 的一个参数 。
- 当您调用 get_int("What's x? ") 时，字符串 "What's x? " 被传递到函数中并存储在变量 prompt 中。
- 将 prompt 视为占位符或变量名 ，它将保存在要求输入时想要显示给用户的任何文本。
- 如果你调用 get_int("Enter a number: ") ，然后在函数 prompt = "Enter a number: "
- 因此， prompt 使功能变得灵活 ——您可以重复使用相同的功能，但使用不同的消息。
  
- prompt 是一个函数参数 。
- 当您调用该函数时，您提供一个参数 （实际的字符串）。
- 该参数存储在参数变量（ prompt ）中并在函数内部使用。


- 详情可见 Python 文档对 <mark>pass</mark> 的说明。 （https://docs.python.org/3/tutorial/controlflow.html#pass-statements）

---

## 小结

错误无法完全避免，但我们可以用今天学到的方法来减少它们的影响。本讲你了解了：

- **Exceptions（异常）**
- **ValueError** 与其他*运行期错误*
- **<mark>try</mark>**
- **<mark>else</mark>**
- **<mark>pass</mark>**
