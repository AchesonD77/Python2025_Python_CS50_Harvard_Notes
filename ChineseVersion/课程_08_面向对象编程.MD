# Lecture 8 — 面向对象编程（README，中文）

> 整理的**第 8 讲**要点；包含 *斜体*、**加粗** 与 <mark>高亮</mark> 强调。

## 目录
- [面向对象编程简介](#面向对象编程简介)
- [类（Classes）](#类classes)
- [`raise` 与异常](#raise-与异常)
- [装饰器 / 属性（@property）](#装饰器--属性property)
- [与以往内容的连接](#与以往内容的连接)
- [类方法](#类方法)
- [静态方法](#静态方法)
- [继承](#继承)
- [继承与异常层级](#继承与异常层级)
- [运算符重载](#运算符重载)
- [总结](#总结)

---

## 面向对象编程（OOP）简介
- 之前多为**过程式**写法；OOP 将**数据+行为**封装在一起，更易维护并可“防御式编程”。
- 从过程式 → 函数抽象 → 字典 → **类** 逐步演进。

### 过程式起点
```py
name = input("Name: ")
house = input("House: ")
print(f"{name} from {house}")
```
- 请注意，该程序遵循程序化的、逐步的范例：就像您在本课程的前几部分看到的那样。

### 抽象输入输出
```py
def main():
    name = get_name()
    house = get_house()
    print(f"{name} from {house}")

def get_name():  
    return input("Name: ")

def get_house(): 
    return input("House: ")

if __name__ == "__main__":
    main()
```
- 注意 get_name 和 get_house 如何抽象出 main 函数的一些需求。此外，请注意上面代码的最后几行是如何告诉解释器运行 main 函数的。


### 多返回值（tuple）

- 我们可以进一步简化程序，将学生存储为 tuple tuple 是值的序列。与 list 不同， tuple 不能被修改。本质上，我们返回两个值。

```python
def main():
    name, house = get_student()
    print(f"{name} from {house}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return name, house


if __name__ == "__main__":
    main()
```

- 注意 get_student 如何返回 name, house 。


- 打包该 tuple ，以便我们能够将两个项目返回给名为 student 变量，我们可以按如下方式修改代码。

```python
def main():
    student = get_student()
    print(f"{student[0]} from {student[1]}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return (name, house)


if __name__ == "__main__":
    main()
```
- 注意， (name, house) 明确地告诉任何阅读我们代码的人，我们在一个值中返回两个值。此外，请注意我们如何使用 student[0] 或 student[1] 来索引 tuple 。


- tuple 是不可变的，这意味着我们无法更改它们的值。不变性是我们进行防御性编程的一种方式。
```python
def main():
    student = get_student()
    if student[0] == "Padma":
        student[1] = "Ravenclaw"
    print(f"{student[0]} from {student[1]}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return name, house


if __name__ == "__main__":
    main()
```
- 注意，这段代码会产生错误。由于 tuple 是不可变的，我们无法重新赋值 student[1] 的值。




### 列表（提供灵活性）/字典版本
```py
def get_student():  # 列表，可变
    return [input("Name: "), input("House: ")]

def get_student():  # 字典，语义更清晰
    return {"name": input("Name: "), "house": input("House: ")}
```

- list
```python

def main():
    student = get_student()
    if student[0] == "Padma":
        student[1] = "Ravenclaw"
    print(f"{student[0]} from {student[1]}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return [name, house]


if __name__ == "__main__":
    main()
```
- 请注意，列表是可变的。也就是说，程序员可以调整 house 和 name 的顺序。在某些情况下，您可能会选择使用此功能，以牺牲代码安全性为代价来提供更大的灵活性。毕竟，如果这些值的顺序可以更改，与您合作的程序员以后可能会犯错误。


- 在此实现中也可以使用字典。回想一下，字典提供的是键值对。
```python
def main():
    student = get_student()
    print(f"{student['name']} from {student['house']}")


def get_student():
    student = {}
    student["name"] = input("Name: ")
    student["house"] = input("House: ")
    return student


if __name__ == "__main__":
    main()
```
- 注意，本例中返回了两个键值对。这种方法的优点在于，我们可以使用键值对来索引这个字典。


- 不过，我们的代码还可以进一步改进。注意，有一个不需要的变量。我们可以删除 student = {} 因为我们不需要创建一个空字典。

```python
def main():
    student = get_student()
    print(f"{student['name']} from {student['house']}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return {"name": name, "house": house}


if __name__ == "__main__":
    main()
```

- 请注意，我们可以在 return 语句中使用 {} 括号来创建字典并在同一行中返回所有内容。


- 我们可以在我们的代码的字典版本中使用 Padma 来提供特殊情况。（可以后期修改）
```py
def main():
    student = get_student()
    if student["name"] == "Padma":
        student["house"] = "Ravenclaw"
    print(f"{student['name']} from {student['house']}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return {"name": name, "house": house}


if __name__ == "__main__":
    main()
```


<mark>为什么用类？</mark> 自定义**类型**，集中**校验**与**方法**，更安全可读。

---

## 类（Classes）

- 在面向对象编程中，类是一种创建我们自己的数据类型并为其命名的方式。类就像是某种数据类型的模型——我们可以发明自己的数据类型并给它们命名。
```py
class Student:
    ...
```
- 我们可以按如下方式修改代码来实现我们自己的名为 Student 类：
```python
class Student:
    ...


def main():
    student = get_student()
    print(f"{student.name} from {student.house}")


def get_student():
    student = Student()
    student.name = input("Name: ")
    student.house = input("House: ")
    return student


if __name__ == "__main__":
    main()
```
- 注意，按照惯例， Student 首字母要大写。另外，注意 ... 仅仅表示我们稍后会返回完成这部分代码。此外，注意在 get_student 中，我们可以使用语法 student = Student() 创建一个 Student 类的 student 。此外，注意我们使用“点符号”来访问 Student 类的变量 student 的属性。

- 任何时候，当你创建一个类并利用该蓝图来创建某些东西时，你都会创建一个所谓的“对象”或“实例”。在我们的代码中， student 就是一个对象。


- 进一步，我们可以为 Student 类对象中预期的属性奠定一些基础。我们可以修改代码如下：
```python
class Student:
    def __init__(self, name, house):
        self.name = name
        self.house = house


def main():
    student = get_student()
    print(f"{student.name} from {student.house}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    student = Student(name, house)
    return student


if __name__ == "__main__":
    main()
```
- 请注意，在 Student 中，我们标准化了该类的属性。我们可以在 class Student 中创建一个函数，称为“方法”，它决定 Student 类对象的行为。在这个函数中，它接收传递给它的 name 和 house 变量，并将这些变量赋值给 Student 类。此外，请注意构造函数 student = Student(name, house) 如何在 Student 类中调用此函数并创建一个 student 。 self 指的是刚刚创建的当前对象。


- 我们可以简化代码如下：
```python
class Student:
    def __init__(self, name, house):
        self.name = name
        self.house = house


def main():
    student = get_student()
    print(f"{student.name} from {student.house}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return Student(name, house) # changed here


if __name__ == "__main__":
    main()
```
- 请注意 return Student(name, house) 如何简化代码的上一次迭代，其中构造函数语句在其自己的行上运行。


- 首先用属性保存数据，然后加入构造器 `__init__` 与易读输出 `__str__`：
```py
class Student:
    def __init__(self, name, house):
        self.name, self.house = name, house
    def __str__(self):
        return f"{self.name} from {self.house}"
```

- 您可以在 Python 的类文档中了解更多信息。https://docs.python.org/3/tutorial/classes.html

---

## `raise` 与异常
- 面向对象编程鼓励您将类的所有功能封装在类定义中。如果出现问题怎么办？如果有人尝试输入随机内容怎么办？如果有人尝试创建一个没有姓名的学生怎么办？请按如下方式修改代码：
  
- 在类内部集中**校验**并在非法时 **raise**：
```py
class Student:
    def __init__(self, name, house):
        if not name:
            raise ValueError("Missing name")
        if house not in ["Gryffindor","Hufflepuff","Ravenclaw","Slytherin"]:
            raise ValueError("Invalid house")
        self.name, self.house = name, house
```
- 注意我们现在如何检查是否提供了名称以及是否指定了正确的房屋。事实证明，我们可以创建自己的异常，通过 raise 来提醒程序员用户可能造成的错误。在上面的例子中，我们抛出了 ValueError 并附带了特定的错误消息。
  


- 碰巧的是，Python 允许你创建一个特定的函数，通过该函数你可以打印对象的属性。修改你的代码如下：
```python
class Student:
    def __init__(self, name, house, patronus):
        if not name:
            raise ValueError("Missing name")
        if house not in ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]:
            raise ValueError("Invalid house")
        self.name = name
        self.house = house
        self.patronus = patronus

    def __str__(self): # 特定的函数
        return f"{self.name} from {self.house}"


def main():
    student = get_student()
    print(student)


def get_student():
    name = input("Name: ")
    house = input("House: ")
    patronus = input("Patronus: ")
    return Student(name, house, patronus)


if __name__ == "__main__":
    main()
```
- 注意 `def __str__(self)` 是如何在调用时返回一个学生信息的。因此，现在作为程序员，你可以打印一个对象、它的属性，或者几乎任何你想要的与该对象相关的内容。


- `__str__` 是 Python 类自带的内置方法。我们也可以为类创建自己的方法！修改代码如下：
- 可扩展行为：
```py
class Student:
    def __init__(self, name, house, patronus=None):
        ...
    def charm(self):
        match self.patronus:
            case "Stag": return "🦌"
            case "Otter": return "🦦"
            case "Jack Russell terrier": return "🐕"
            case _: return "✨"
```
- 注意我们如何定义自己的方法 charm 。与字典不同，类可以拥有内置函数，称为方法。在本例中，我们定义了 charm 方法，特定情况会产生特定结果。此外，请注意，Python 能够直接在代码中使用表情符号。

- 请注意我们只有两种方法： __init__ 和 __str__ 。
---

## 装饰器 / 属性（`@property`）
- 通过 **`@property`** + 私有字段如 `_house`，实现“点语法访问、赋值即校验”。
- 属性可以用来强化我们的代码。在 Python 中，我们使用以 @ 开头的函数“装饰器”来定义属性。

```py
class Student:
    def __init__(self, name, house):
        self.name = name
        self.house = house

    def __str__(self):
        return f"{self.name} from {self.house}"

    # Getter for name
    @property
    def name(self):
        return self._name

    # Setter for name
    @name.setter
    def name(self, name):
        if not name:
            raise ValueError("Invalid name")
        self._name = name

    @property
    def house(self):
        return self._house

    @house.setter
    def house(self, house):
        if house not in ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]:
            raise ValueError("Invalid house")
        self._house = house


def main():
    student = get_student()
    print(student)


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return Student(name, house)


if __name__ == "__main__":
    main()
```
- 注意我们在名为 house 函数上方编写了 @property 。这样做将 house 定义为我们类的一个属性。有了 house 作为属性，我们就可以定义如何设置和检索类的某些属性 _house 。实际上，我们现在可以通过 @house.setter 定义一个名为“setter”的函数，每当设置 house 属性时都会调用该函数 - 例如，设置 student.house = "Gryffindor" 。在这里，我们让 setter 为我们验证 house 的值。注意，如果 house 的值不是任何哈利波特房屋，我们会引发 ValueError 否则，我们将使用 house 来更新 _house 的值。为什么是 _house 而不是 house ？ house 是我们类的一个属性，用户可以通过它尝试设置我们的类属性。 _house 就是该类属性本身。前导下划线 _ 向用户指示他们不需要（事实上，也不应该！）直接修改此值。 _house 只能通过 house setter 来设置。请注意， house 属性只是返回 _house 的值，而 _house 是我们类的属性，它大概已经通过 house setter 进行了验证。当用户调用 student.house 时，他们通过 house 的 getter 获取 _house 的值。

> 这段文字主要介绍了在 Python 中如何利用 @property 装饰器定义类属性，以及如何通过 getter 和 setter 方法实现数据封装和输入校验。 
> 1. 定义属性 (@property)： 在一个函数（例如 house）上方使用 @property，可以将该函数转换为类的属性。当用户访问这个属性时（例如 student.house），实际上是调用了这个属性的 getter 函数。
> 2. 设置器（Setter，@house.setter）： 通过 @属性名.setter 装饰器来定义设置器函数。当用户尝试给这个属性赋值时（例如 student.house = "Gryffindor"），设置器会自动被调用。
> 3. 封装与校验： 设置器的主要职责是验证输入值。文中的例子展示了设置器如何检查赋给属性的值是否符合预设的条件（例如是否为有效的霍格沃茨学院），如果不符合则抛出 ValueError。
> 4. 内部属性 (_house)： 属性通过一个带有前导下划线（例如 _house）的内部类属性来存储实际的数据。这个下划线表明该属性是受保护的，用户不应直接修改它，而应该始终通过定义好的 setter 方法进行设置。

<mark>经验：</mark> 只在**构造器/Setter**校验一次，其他地方重用即可。
- 您可以在 Python 的方法文档中了解更多信息。 https://docs.python.org/3/tutorial/classes.html

---

## 与以往内容的连接
你早已在使用类：`int`、`str`、`list`、`dict`：
```py
print(type(50)), print(type("hi")), print(type([1])), print(type({"a":1}))
```

- 如果你深入研究 int 的文档，你会发现它是一个带有构造函数的类。它是创建 int 类型对象的蓝图。你可以在 Python 的 int 文档中了解更多信息。 https://docs.python.org/3/library/functions.html#int

- 字符串也是一个类。如果你使用过 str.lower() ，那么你使用的就是 str 类中的一个方法。你可以在 Python 的 str 文档中了解更多信息。 https://docs.python.org/3/library/stdtypes.html#str

- list 也是一个类。查看 list 的文档，你可以看到其中包含的方法，例如 list.append() 。你可以在 Python 的 list 文档中了解更多信息。 https://docs.python.org/3/library/stdtypes.html#list

- dict 也是 Python 中的一个类。你可以在 Python 的 dict 文档中了解更多信息。 https://docs.python.org/3/library/stdtypes.html#dict

---

## 类方法
**`@classmethod`** 作用于“类本身”，可作**备用构造器**：
- 有时，我们想向类本身添加功能，而不是向该类的实例添加功能。
- @classmethod 是一个函数，我们可以使用它来为整个类添加功能。
  

- 下面是一个不使用类方法的示例。在终端窗口中，输入 code hat.py 并执行如下代码：
```python
import random


class Hat:
    def __init__(self):
        self.houses = ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]

    def sort(self, name):
        print(name, "is in", random.choice(self.houses))


hat = Hat()
hat.sort("Harry")
```
- 注意，当我们将学生的名字传递给分院帽时，它会告诉我们学生被分配到哪个学院。注意， hat = Hat() 实例化了一个 hat 。 sort 功能始终由 Hat 类的实例处理。通过执行 hat.sort("Harry") ，我们将学生的名字传递给了 Hat 类实例的 sort 方法，我们将其命名为 hat 。


- 不过，我们可能想在不创建分院帽实例的情况下运行 sort 函数（毕竟只有一个！）。我们可以修改代码如下：
```py
import random
class Hat:
    houses = ["Gryffindor","Hufflepuff","Ravenclaw","Slytherin"]
    @classmethod
    def sort(cls, name):
        print(name, "is in", random.choice(cls.houses))
Hat.sort("Harry")
```
- 注意 __init__ 方法被移除了，因为我们不需要在代码的任何地方实例化一个 hat。因此， self 不再重要，因此被移除了。我们将此 sort 指定为 @classmethod ，将 self 替换为 cls 。最后，请注意，在代码末尾， Hat 按照惯例被大写，因为这是我们类的名称。


- 回到 students.py 我们可以按如下方式修改代码，解决一些与 @classmethod 相关的错过的机会：
```py
class Student:
    ...
    @classmethod
    def get(cls):
        return cls(input("Name: "), input("House: "))
```
- 注意， get_student 已被移除，并创建了一个名为 get 的 @classmethod 。现在无需先创建学生即可调用此方法。


---

## 静态方法
**`@staticmethod`**：与实例、类状态都无关的工具函数，放到类命名空间中。

---

## 继承
- 继承也许是面向对象编程最强大的特性。
- 碰巧的是，您可以创建一个从另一个类“继承”方法、变量和属性的类。
```py
class Wizard:
    def __init__(self, name):
        if not name: raise ValueError("Missing name")
        self.name = name

class Student(Wizard):
    def __init__(self, name, house):
        super().__init__(name)
        self.house = house

class Professor(Wizard):
    def __init__(self, name, subject):
        super().__init__(name)
        self.subject = subject
```
- 请注意，上面有一个名为 Wizard 类和一个名为 Student 类。此外，请注意，还有一个名为 Professor 类。学生和教授都有名字。而且，他们都是巫师。因此， Student 和 Professor 都继承了 Wizard 的特征。在“子”类 Student 中， Student 可以从“父”类或“超”类 Wizard 继承，因为 super().\__init__(name) 这行代码运行了 Wizard 的 init 方法。最后，请注意，这段代码的最后几行创建了一个名为 Albus 的巫师、一个名为 Harry 的学生等等。


---

## 继承与异常层级
- 异常是**树形结构**；捕获父类可统一处理子类（如 `Exception` 捕获 `ValueError` 等）。
```
  BaseException
 +-- KeyboardInterrupt
 +-- Exception
      +-- ArithmeticError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- KeyError
      +-- NameError
      +-- SyntaxError
      |    +-- IndentationError
      +-- ValueError
 ...
 ```
- 您可以在 Python 的异常文档中了解更多信息。 https://docs.python.org/3/library/exceptions.html
---

## 运算符重载
一些运算符（例如 + 和 - 可以“重载”，这样它们就可以具有超出简单算术的更多功能。
```py
class Vault:
    def __init__(self, galleons=0, sickles=0, knuts=0):
        self.galleons = galleons
        self.sickles = sickles
        self.knuts = knuts

    def __str__(self):
        return f"{self.galleons} Galleons, {self.sickles} Sickles, {self.knuts} Knuts"

    def __add__(self, other):
        galleons = self.galleons + other.galleons
        sickles = self.sickles + other.sickles
        knuts = self.knuts + other.knuts
        return Vault(galleons, sickles, knuts)


potter = Vault(100, 50, 25)
print(potter)

weasley = Vault(25, 50, 100)
print(weasley)

total = potter + weasley
print(total)
```
- 注意 __str__ 方法如何 self 一个格式化的字符串。此外，请注意 __add__ 方法如何允许将两个 vault 的值相加。self 是 + 操作数左侧的值。other 是 + 操作数右侧的 other 。
- 您可以在 Python 的运算符重载文档中了解更多信息。 https://docs.python.org/3/reference/datamodel.html#special-method-names
---

## 总结
- <mark>核心能力：</mark> **OOP、类、`raise`、`@property`、类/静态方法、继承、运算符重载**。  
- **实践建议：** 将校验收敛到类内部；用属性暴露安全状态；保持不变式清晰；适度重载运算符。
```
面向对象编程
类
抛出raise
类方法
静态方法
继承
运算符重载
```