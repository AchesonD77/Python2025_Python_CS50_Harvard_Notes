# Lecture 8 — 面向对象编程（README，中文）

> 整理的**第 8 讲**要点；包含 *斜体*、**加粗** 与 <mark>高亮</mark> 强调。

## 目录
- [面向对象编程简介](#面向对象编程简介)
- [类（Classes）](#类classes)
- [`raise` 与异常](#raise-与异常)
- [装饰器 / 属性（@property）](#装饰器--属性property)
- [与以往内容的连接](#与以往内容的连接)
- [类方法](#类方法)
- [静态方法](#静态方法)
- [继承](#继承)
- [继承与异常层级](#继承与异常层级)
- [运算符重载](#运算符重载)
- [总结](#总结)

---

## 面向对象编程（OOP）简介
- 之前多为**过程式**写法；OOP 将**数据+行为**封装在一起，更易维护并可“防御式编程”。
- 从过程式 → 函数抽象 → 字典 → **类** 逐步演进。

### 过程式起点
```py
name = input("Name: ")
house = input("House: ")
print(f"{name} from {house}")
```
- 请注意，该程序遵循程序化的、逐步的范例：就像您在本课程的前几部分看到的那样。

### 抽象输入输出
```py
def main():
    name = get_name()
    house = get_house()
    print(f"{name} from {house}")

def get_name():  
    return input("Name: ")

def get_house(): 
    return input("House: ")

if __name__ == "__main__":
    main()
```
- 注意 get_name 和 get_house 如何抽象出 main 函数的一些需求。此外，请注意上面代码的最后几行是如何告诉解释器运行 main 函数的。


### 多返回值（tuple）

- 我们可以进一步简化程序，将学生存储为 tuple tuple 是值的序列。与 list 不同， tuple 不能被修改。本质上，我们返回两个值。

```python
def main():
    name, house = get_student()
    print(f"{name} from {house}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return name, house


if __name__ == "__main__":
    main()
```

- 注意 get_student 如何返回 name, house 。


- 打包该 tuple ，以便我们能够将两个项目返回给名为 student 变量，我们可以按如下方式修改代码。

```python
def main():
    student = get_student()
    print(f"{student[0]} from {student[1]}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return (name, house)


if __name__ == "__main__":
    main()
```
- 注意， (name, house) 明确地告诉任何阅读我们代码的人，我们在一个值中返回两个值。此外，请注意我们如何使用 student[0] 或 student[1] 来索引 tuple 。


- tuple 是不可变的，这意味着我们无法更改它们的值。不变性是我们进行防御性编程的一种方式。
```python
def main():
    student = get_student()
    if student[0] == "Padma":
        student[1] = "Ravenclaw"
    print(f"{student[0]} from {student[1]}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return name, house


if __name__ == "__main__":
    main()
```
- 注意，这段代码会产生错误。由于 tuple 是不可变的，我们无法重新赋值 student[1] 的值。




### 列表（提供灵活性）/字典版本
```py
def get_student():  # 列表，可变
    return [input("Name: "), input("House: ")]

def get_student():  # 字典，语义更清晰
    return {"name": input("Name: "), "house": input("House: ")}
```

- list
```python

def main():
    student = get_student()
    if student[0] == "Padma":
        student[1] = "Ravenclaw"
    print(f"{student[0]} from {student[1]}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return [name, house]


if __name__ == "__main__":
    main()
```
- 请注意，列表是可变的。也就是说，程序员可以调整 house 和 name 的顺序。在某些情况下，您可能会选择使用此功能，以牺牲代码安全性为代价来提供更大的灵活性。毕竟，如果这些值的顺序可以更改，与您合作的程序员以后可能会犯错误。


- 在此实现中也可以使用字典。回想一下，字典提供的是键值对。
```python
def main():
    student = get_student()
    print(f"{student['name']} from {student['house']}")


def get_student():
    student = {}
    student["name"] = input("Name: ")
    student["house"] = input("House: ")
    return student


if __name__ == "__main__":
    main()
```
- 注意，本例中返回了两个键值对。这种方法的优点在于，我们可以使用键值对来索引这个字典。


- 不过，我们的代码还可以进一步改进。注意，有一个不需要的变量。我们可以删除 student = {} 因为我们不需要创建一个空字典。

```python
def main():
    student = get_student()
    print(f"{student['name']} from {student['house']}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return {"name": name, "house": house}


if __name__ == "__main__":
    main()
```

- 请注意，我们可以在 return 语句中使用 {} 括号来创建字典并在同一行中返回所有内容。


- 我们可以在我们的代码的字典版本中使用 Padma 来提供特殊情况。（可以后期修改）
```py
def main():
    student = get_student()
    if student["name"] == "Padma":
        student["house"] = "Ravenclaw"
    print(f"{student['name']} from {student['house']}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return {"name": name, "house": house}


if __name__ == "__main__":
    main()
```


<mark>为什么用类？</mark> 自定义**类型**，集中**校验**与**方法**，更安全可读。

---

## 类（Classes）

- 在面向对象编程中，类是一种创建我们自己的数据类型并为其命名的方式。类就像是某种数据类型的模型——我们可以发明自己的数据类型并给它们命名。
```py
class Student:
    ...
```
- 我们可以按如下方式修改代码来实现我们自己的名为 Student 类：
```python
class Student:
    ...


def main():
    student = get_student()
    print(f"{student.name} from {student.house}")


def get_student():
    student = Student()
    student.name = input("Name: ")
    student.house = input("House: ")
    return student


if __name__ == "__main__":
    main()
```
- 注意，按照惯例， Student 首字母要大写。另外，注意 ... 仅仅表示我们稍后会返回完成这部分代码。此外，注意在 get_student 中，我们可以使用语法 student = Student() 创建一个 Student 类的 student 。此外，注意我们使用“点符号”来访问 Student 类的变量 student 的属性。

- 任何时候，当你创建一个类并利用该蓝图来创建某些东西时，你都会创建一个所谓的“对象”或“实例”。在我们的代码中， student 就是一个对象。


- 进一步，我们可以为 Student 类对象中预期的属性奠定一些基础。我们可以修改代码如下：
```python
class Student:
    def __init__(self, name, house):
        self.name = name
        self.house = house


def main():
    student = get_student()
    print(f"{student.name} from {student.house}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    student = Student(name, house)
    return student


if __name__ == "__main__":
    main()
```
- 请注意，在 Student 中，我们标准化了该类的属性。我们可以在 class Student 中创建一个函数，称为“方法”，它决定 Student 类对象的行为。在这个函数中，它接收传递给它的 name 和 house 变量，并将这些变量赋值给 Student 类。此外，请注意构造函数 student = Student(name, house) 如何在 Student 类中调用此函数并创建一个 student 。 self 指的是刚刚创建的当前对象。


- 我们可以简化代码如下：
```python
class Student:
    def __init__(self, name, house):
        self.name = name
        self.house = house


def main():
    student = get_student()
    print(f"{student.name} from {student.house}")


def get_student():
    name = input("Name: ")
    house = input("House: ")
    return Student(name, house) # changed here


if __name__ == "__main__":
    main()
```
- 请注意 return Student(name, house) 如何简化代码的上一次迭代，其中构造函数语句在其自己的行上运行。


- 首先用属性保存数据，然后加入构造器 `__init__` 与易读输出 `__str__`：
```py
class Student:
    def __init__(self, name, house):
        self.name, self.house = name, house
    def __str__(self):
        return f"{self.name} from {self.house}"
```

- 您可以在 Python 的类文档中了解更多信息。https://docs.python.org/3/tutorial/classes.html

---

## `raise` 与异常
- 面向对象编程鼓励您将类的所有功能封装在类定义中。如果出现问题怎么办？如果有人尝试输入随机内容怎么办？如果有人尝试创建一个没有姓名的学生怎么办？请按如下方式修改代码：
  
- 在类内部集中**校验**并在非法时 **raise**：
```py
class Student:
    def __init__(self, name, house):
        if not name:
            raise ValueError("Missing name")
        if house not in ["Gryffindor","Hufflepuff","Ravenclaw","Slytherin"]:
            raise ValueError("Invalid house")
        self.name, self.house = name, house
```
- 注意我们现在如何检查是否提供了名称以及是否指定了正确的房屋。事实证明，我们可以创建自己的异常，通过 raise 来提醒程序员用户可能造成的错误。在上面的例子中，我们抛出了 ValueError 并附带了特定的错误消息。
  


- 碰巧的是，Python 允许你创建一个特定的函数，通过该函数你可以打印对象的属性。修改你的代码如下：
```python
class Student:
    def __init__(self, name, house, patronus):
        if not name:
            raise ValueError("Missing name")
        if house not in ["Gryffindor", "Hufflepuff", "Ravenclaw", "Slytherin"]:
            raise ValueError("Invalid house")
        self.name = name
        self.house = house
        self.patronus = patronus

    def __str__(self): # 特定的函数
        return f"{self.name} from {self.house}"


def main():
    student = get_student()
    print(student)


def get_student():
    name = input("Name: ")
    house = input("House: ")
    patronus = input("Patronus: ")
    return Student(name, house, patronus)


if __name__ == "__main__":
    main()
```
- 注意 `def __str__(self)` 是如何在调用时返回一个学生信息的。因此，现在作为程序员，你可以打印一个对象、它的属性，或者几乎任何你想要的与该对象相关的内容。


- `__str__` 是 Python 类自带的内置方法。我们也可以为类创建自己的方法！修改代码如下：
- 可扩展行为：
```py
class Student:
    def __init__(self, name, house, patronus=None):
        ...
    def charm(self):
        match self.patronus:
            case "Stag": return "🦌"
            case "Otter": return "🦦"
            case "Jack Russell terrier": return "🐕"
            case _: return "✨"
```
- 注意我们如何定义自己的方法 charm 。与字典不同，类可以拥有内置函数，称为方法。在本例中，我们定义了 charm 方法，特定情况会产生特定结果。此外，请注意，Python 能够直接在代码中使用表情符号。

- 请注意我们只有两种方法： __init__ 和 __str__ 。
---

## 装饰器 / 属性（`@property`）
- 通过 **`@property`** + 私有字段如 `_house`，实现“点语法访问、赋值即校验”。
```py
class Student:
    def __init__(self, name, house):
        if not name: raise ValueError("Invalid name")
        self._name = name
        self.house = house  # 触发 setter

    @property
    def name(self): return self._name
    @name.setter
    def name(self, v):
        if not v: raise ValueError("Invalid name")
        self._name = v

    @property
    def house(self): return self._house
    @house.setter
    def house(self, v):
        if v not in {"Gryffindor","Hufflepuff","Ravenclaw","Slytherin"}:
            raise ValueError("Invalid house")
        self._house = v
```
<mark>经验：</mark> 只在**构造器/Setter**校验一次，其他地方重用即可。

---

## 与以往内容的连接
你早已在使用类：`int`、`str`、`list`、`dict`：
```py
print(type(50)), print(type("hi")), print(type([1])), print(type({"a":1}))
```

---

## 类方法
**`@classmethod`** 作用于“类本身”，可作**备用构造器**：
```py
import random
class Hat:
    houses = ["Gryffindor","Hufflepuff","Ravenclaw","Slytherin"]
    @classmethod
    def sort(cls, name):
        print(name, "is in", random.choice(cls.houses))
```
```py
class Student:
    ...
    @classmethod
    def get(cls):
        return cls(input("Name: "), input("House: "))
```

---

## 静态方法
**`@staticmethod`**：与实例、类状态都无关的工具函数，放到类命名空间中。

---

## 继承
```py
class Wizard:
    def __init__(self, name):
        if not name: raise ValueError("Missing name")
        self.name = name

class Student(Wizard):
    def __init__(self, name, house):
        super().__init__(name)
        self.house = house

class Professor(Wizard):
    def __init__(self, name, subject):
        super().__init__(name)
        self.subject = subject
```

---

## 继承与异常层级
- 异常是**树形结构**；捕获父类可统一处理子类（如 `Exception` 捕获 `ValueError` 等）。

---

## 运算符重载
通过 **dunder** 方法赋予类型更多语义：
```py
class Vault:
    def __init__(self, g=0, s=0, k=0):
        self.galleons, self.sickles, self.knuts = g, s, k
    def __str__(self):
        return f"{self.galleons} Galleons, {self.sickles} Sickles, {self.knuts} Knuts"
    def __add__(self, other):
        return Vault(self.galleons+other.galleons,
                     self.sickles+other.sickles,
                     self.knuts+other.knuts)
```

---

## 总结
- <mark>核心能力：</mark> **OOP、类、`raise`、`@property`、类/静态方法、继承、运算符重载**。  
- **实践建议：** 将校验收敛到类内部；用属性暴露安全状态；保持不变式清晰；适度重载运算符。
