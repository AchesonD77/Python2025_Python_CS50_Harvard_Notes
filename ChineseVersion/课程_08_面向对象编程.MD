# Lecture 8 — 面向对象编程（README，中文）

> 依据截图整理的**第 8 讲**要点；包含 *斜体*、**加粗** 与 <mark>高亮</mark> 强调。

## 目录
- [面向对象编程简介](#面向对象编程简介)
- [类（Classes）](#类classes)
- [`raise` 与异常](#raise-与异常)
- [装饰器 / 属性（@property）](#装饰器--属性property)
- [与以往内容的连接](#与以往内容的连接)
- [类方法](#类方法)
- [静态方法](#静态方法)
- [继承](#继承)
- [继承与异常层级](#继承与异常层级)
- [运算符重载](#运算符重载)
- [总结](#总结)

---

## 面向对象编程简介
- 之前多为**过程式**写法；OOP 将**数据+行为**封装在一起，更易维护并可“防御式编程”。
- 从过程式 → 函数抽象 → 字典 → **类** 逐步演进。

### 过程式起点
```py
name = input("Name: ")
house = input("House: ")
print(f"{name} from {house}")
```

### 抽象输入输出
```py
def main():
    name = get_name()
    house = get_house()
    print(f"{name} from {house}")

def get_name():  return input("Name: ")
def get_house(): return input("House: ")

if __name__ == "__main__":
    main()
```

### 多返回值（tuple）
```py
def get_student():
    return input("Name: "), input("House: ")  # 元组，**不可变**
```

### 列表/字典版本
```py
def get_student():  # 列表，可变
    return [input("Name: "), input("House: ")]

def get_student():  # 字典，语义更清晰
    return {"name": input("Name: "), "house": input("House: ")}
```

<mark>为什么用类？</mark> 自定义**类型**，集中**校验**与**方法**，更安全可读。

---

## 类（Classes）
```py
class Student:
    ...
```
- 首先用属性保存数据，然后加入构造器 `__init__` 与易读输出 `__str__`：
```py
class Student:
    def __init__(self, name, house):
        self.name, self.house = name, house
    def __str__(self):
        return f"{self.name} from {self.house}"
```

---

## `raise` 与异常
- 在类内部集中**校验**并在非法时 **raise**：
```py
class Student:
    def __init__(self, name, house):
        if not name:
            raise ValueError("Missing name")
        if house not in ["Gryffindor","Hufflepuff","Ravenclaw","Slytherin"]:
            raise ValueError("Invalid house")
        self.name, self.house = name, house
```
- 可扩展行为：
```py
class Student:
    def __init__(self, name, house, patronus=None):
        ...
    def charm(self):
        match self.patronus:
            case "Stag": return "🦌"
            case "Otter": return "🦦"
            case "Jack Russell terrier": return "🐕"
            case _: return "✨"
```

---

## 装饰器 / 属性（`@property`）
- 通过 **`@property`** + 私有字段如 `_house`，实现“点语法访问、赋值即校验”。
```py
class Student:
    def __init__(self, name, house):
        if not name: raise ValueError("Invalid name")
        self._name = name
        self.house = house  # 触发 setter

    @property
    def name(self): return self._name
    @name.setter
    def name(self, v):
        if not v: raise ValueError("Invalid name")
        self._name = v

    @property
    def house(self): return self._house
    @house.setter
    def house(self, v):
        if v not in {"Gryffindor","Hufflepuff","Ravenclaw","Slytherin"}:
            raise ValueError("Invalid house")
        self._house = v
```
<mark>经验：</mark> 只在**构造器/Setter**校验一次，其他地方重用即可。

---

## 与以往内容的连接
你早已在使用类：`int`、`str`、`list`、`dict`：
```py
print(type(50)), print(type("hi")), print(type([1])), print(type({"a":1}))
```

---

## 类方法
**`@classmethod`** 作用于“类本身”，可作**备用构造器**：
```py
import random
class Hat:
    houses = ["Gryffindor","Hufflepuff","Ravenclaw","Slytherin"]
    @classmethod
    def sort(cls, name):
        print(name, "is in", random.choice(cls.houses))
```
```py
class Student:
    ...
    @classmethod
    def get(cls):
        return cls(input("Name: "), input("House: "))
```

---

## 静态方法
**`@staticmethod`**：与实例、类状态都无关的工具函数，放到类命名空间中。

---

## 继承
```py
class Wizard:
    def __init__(self, name):
        if not name: raise ValueError("Missing name")
        self.name = name

class Student(Wizard):
    def __init__(self, name, house):
        super().__init__(name)
        self.house = house

class Professor(Wizard):
    def __init__(self, name, subject):
        super().__init__(name)
        self.subject = subject
```

---

## 继承与异常层级
- 异常是**树形结构**；捕获父类可统一处理子类（如 `Exception` 捕获 `ValueError` 等）。

---

## 运算符重载
通过 **dunder** 方法赋予类型更多语义：
```py
class Vault:
    def __init__(self, g=0, s=0, k=0):
        self.galleons, self.sickles, self.knuts = g, s, k
    def __str__(self):
        return f"{self.galleons} Galleons, {self.sickles} Sickles, {self.knuts} Knuts"
    def __add__(self, other):
        return Vault(self.galleons+other.galleons,
                     self.sickles+other.sickles,
                     self.knuts+other.knuts)
```

---

## 总结
- <mark>核心能力：</mark> **OOP、类、`raise`、`@property`、类/静态方法、继承、运算符重载**。  
- **实践建议：** 将校验收敛到类内部；用属性暴露安全状态；保持不变式清晰；适度重载运算符。
