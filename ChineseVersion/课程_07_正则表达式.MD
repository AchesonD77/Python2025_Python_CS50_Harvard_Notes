# 第 7 讲 — 正则表达式、清洗输入、提取数据

> *目标：* 学会用 Python 的 `re` 模块来**校验**、**清洗**与**提取**用户输入。

## 目录
- [正则表达式基础](#正则表达式基础)
- [大小写敏感](#大小写敏感)
- [清洗用户输入](#清洗用户输入)
- [提取用户输入](#提取用户输入)
- [总结](#总结)

- 可以参考链接：https://cs50.harvard.edu/python/notes/7/

---

## 正则表达式常用符号及规则列表

### 一、 字符匹配（Character Matching）
- 符号意义（规则） 示例匹配结果
- .  匹配除换行符以外的任何单个字符。a.c匹配 abc, aXc, a1c 等。
- [] 字符集：匹配方括号内的任何一个字符。[aeiou]匹配 a, e, i, o, u 中的任意一个。
- [^]排除字符集：匹配不在方括号内的任何字符。[^0-9]匹配任何非数字字符。[a-z]范围：匹配从 a 到 z 范围内的任何字符。[A-Z0-9]匹配任何大写字母或数字。
- |或 (OR)：匹配符号左右两边的任一表达式。

### 二、 量词（Quantifiers）量词决定了前面表达式出现的次数。
- 符号意义（规则）示例匹配结果
- '\*' 匹配前面的表达式 零次或多次 (>= 0)。a*b匹配 b, ab, aaab 等。 
- +匹配前面的表达式 一次或多次 (>= 1)。a+b匹配 ab, aaab，但不匹配 b。 
- ? 匹配前面的表达式 零次或一次（可选）。colou?r匹配 color 或 colour。 
- {n} 匹配前面的表达式 恰好 n 次。\d{4}匹配恰好 4 个数字（如 2023）。 
  
- {n,}匹配前面的表达式 至少 n 次。\w{5,}匹配至少 5 个字母/数字/下划线。 
  
- {n,m}匹配前面的表达式 n 到 m 次。A{1,3}匹配 A, AA, 或 AAA。
  
### 三、 边界匹配（Anchors and Boundaries）

这些符号匹配的是位置，而不是具体的字符。
符号意义（规则）示例匹配结果
- ^开头：匹配字符串的开始位置。^Hello匹配以 Hello 开头的字符串。 
  
- $结尾：匹配字符串的结束位置。World$匹配以 World 结尾的字符串。
  
- \b单词边界 (Word Boundary)：匹配单词字符和非单词字符之间的位置。\bcat\b只匹配单独的单词 cat，不匹配 concatenate 中的 cat。
  
- \B非单词边界：与 \b 相反。\Bcat\B匹配 concatenate 中的 cat。
  
### 四、 简写字符集（Shorthand Character Classes）

这些是常用的字符集的简写形式。
符号意义（规则）相当于
- \d数字：匹配任何数字（0-9）。[0-9]
  
- \D非数字：匹配任何非数字字符。[^0-9]
  
- \w单词字符：匹配任何字母、数字或下划线。[a-zA-Z0-9_]
  
- \W非单词字符：匹配任何非字母、数字、下划线的字符。[^a-zA-Z0-9_]
  
- \s空白字符：匹配任何空格、制表符、换行符等。[ \t\n\r\f\v]
  
- \S非空白字符：与 \s 相反。[^ \t\n\r\f\v]
  
### 五、 分组与捕获（Grouping and Capturing）
符号意义（规则）示例 目的
- ()分组与捕获：将括号内的表达式视为一个整体，并捕获匹配到的文本。(ab)+ 匹配 ab 或 abab 等，并可以提取 ab。
- (?:...)非捕获分组：将括号内的表达式视为一个整体，但不捕获匹配到的文本。(?:www\.)?匹配可选的 www.，但不会将其结果作为提取数据保存。
  
- \n反向引用：引用第 $n$ 个捕获组匹配的文本。
  
- (\w)\1匹配任何两个连续相同的字符（如 aa, bb）。
  
### 六、 转义符（Escape Character）
符号意义（规则）示例目的
- \转义：将后面紧跟的特殊字符转换为字面字符，或将字面字符转换为特殊字符（如 \d）。
  
- \.匹配字面句点 .，而不是通配符。
  
- \(匹配字面圆括号 (，而不是分组的开始。
  
- 掌握了以上这些基础符号，您就能读懂并编写绝大多数常见的正则表达式了。

---

## 正则表达式基础

正则（*regex*）用于匹配**模式**，而不是简单找子串。

### 1）朴素检查
```py
email = input("What's your email? ").strip()
if "@" in email:
    print("Valid")
else:
    print("Invalid")
```
- 问题：仅 `@` 也会通过。改进为同时包含 `@` 与 `.`：
```py
email = input("What's your email? ").strip()
if "@" in email and "." in email:
    print("Valid")
else:
    print("Invalid")
```
仍不严谨。

### 2）拆分成用户名与域名
```py
email = input("What's your email? ").strip()
username, domain = email.split("@")
if username and "." in domain:
    print("Valid")
else:
    print("Invalid")
```
依旧接受如 `malan@harvard?edu` 之类的坏输入。

### 3）使用 `re.search`
<mark>核心：用**模式**描述合法结构。</mark>
```py
import re
email = input("What's your email? ").strip()
if re.search(r"@.+", email):
    print("Valid")
else:
    print("Invalid")
```
常用语法：

- `.` 任意字符（不含换行）  
- `*`/`+`/`?`、`{m}`、`{m,n}` 重复次数  
- `^` 行首，`$` 行尾  
- 字符类 `[abc]`、排除 `[^abc]`、范围 `[a-zA-Z0-9_]`  
- `\w` 字符、`\W` 非字符、`\d` 数字、`\D` 非数字、`\s` 空白、`\S` 非空白。

### 4）收紧邮箱规则
```py
import re
email = input("What's your email? ").strip()
if re.search(r"^[\w]+@[\w]+\.edu$", email):
    print("Valid")
else:
    print("Invalid")
```
- `^...$` 确保**整串**匹配。
- <mark>要点：</mark> 使用 **原始字符串** `r"...“`，避免反斜杠被 Python 吃掉。

### 5）更通用的后缀
```py
if re.search(r"^[\w]+@[\w]+\.(com|edu|gov|net|org)$", email):
    ...
```
或
```py
if re.fullmatch(r"[A-Za-z0-9_]+@[A-Za-z0-9_]+\.[A-Za-z]{2,}", email):
    print("Valid")
else:
    print("Invalid")
```
- <mark>推荐：</mark>需要匹配**整个字符串**时用 **`re.fullmatch`**。

## 大小写敏感

默认区分大小写。用 `re.IGNORECASE` 忽略大小写：
```py
import re
if re.search(r"^[\w]+@[\w]+\.edu$", email, re.IGNORECASE):
    print("Valid (case-insensitive)")
```
其他常用：`re.MULTILINE`, `re.DOTALL`。

## 清洗用户输入

把“**Malan, David**”标准化为“**David Malan**”。

**方式 1：split**
```py
name = input("What's your name? ").strip()
if "," in name:
    last, first = name.split(", ")
    name = f"{first} {last}"
print(f"Hello, {name}")
```

**方式 2：正则分组**
```py
import re
name = input("What's your name? ").strip()
m = re.search(r"^(.+),\s*(.+)$", name)
if m:
    name = m.group(2) + " " + m.group(1)
print(f"Hello, {name}")
```
- `\s*` 吃掉多余空格。
- **海象运算符**一次完成匹配与判断：
```py
if m := re.search(r"^(.+),\s*(.+)$", name):
    name = f"{m.group(2)} {m.group(1)}"
```

## 提取用户输入

从 Twitter URL 中抽取**用户名**。

**替换法（脆弱）**
```py
url = input("URL: ").strip()
username = url.replace("https://twitter.com/", "")
print("Username:", username)
```

**正则替换**
```py
import re
url = input("URL: ").strip()
username = re.sub(r"^https?://(www\.)?twitter\.com/", "", url, flags=re.IGNORECASE)
print("Username:", username)
```

**验证 + 捕获**
```py
import re
url = input("URL: ").strip()
if m := re.search(r"^https?://(?:www\.)?twitter\.com/([a-z0-9_]+)$", url, re.IGNORECASE):
    print("Username:", m.group(1))
```
- `(?:...)` 非捕获分组；`[a-z0-9_]+` 合法字符 1+。
- <mark>最佳实践：</mark>尽量在**同一个**正则里完成“校验 + 提取”。

## 总结

- **正则基础**：元字符、重复、锚点、字符类与分组。  
- **标志位**：<mark>re.IGNORECASE</mark>、`re.MULTILINE`、`re.DOTALL`。  
- **清洗输入**：分组与**海象运算符**结合更优雅。  
- **提取结构化数据**：用一个精确的正则完成匹配与捕获。

> 提示：保持模式**可读**；优先使用**原始字符串**与**锚点**；验证整串时用 **`re.fullmatch`**。
