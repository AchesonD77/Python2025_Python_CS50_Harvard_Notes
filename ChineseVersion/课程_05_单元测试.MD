# 讲义 5 — 单元测试、`assert`、`pytest`

## 目录
- [单元测试](#单元测试)
- [`assert` 断言](#assert-断言)
- [`pytest` 框架](#pytest-框架)
- [测试字符串](#测试字符串)
- [按文件夹目录组织测试](#按文件夹目录组织测试)
- [小结](#小结)

---

## 单元测试

- 以前我们常用 `print` 来“目测”结果；在工程实践中，我们会**写代码来测试代码**（*unit tests*）。

```python
# calculator.py
def main():
    x = int(input("What's x? "))
    print("x squared is", square(x))

def square(n):
    return n * n

if __name__ == "__main__":
    main()
```

- 初版测试：

```python
# test_calculator.py
from calculator import square

def main():
    test_square()

def test_square():
    if square(2) != 4:
        print("2 squared was not 4")
    if square(3) != 9:
        print("3 squared was not 9")

if __name__ == "__main__":
    main()
```

<mark>问题：</mark>无输出不代表正确，且**难扩展**。在控制台窗口中，输入 python test_calculator.py 。你会发现没有任何输出。这可能是因为一切运行正常！也可能是我们的测试函数没有发现可能导致错误的“极端情况”。

---

## `assert` 断言

- 用 **`assert`** 声明某条件必须成立：
- Python 的 assert 命令允许我们告诉解释器某个断言为真。
```python
from calculator import square

def main():
    test_square()

def test_square():
    assert square(2) == 4
    assert square(3) == 9

if __name__ == "__main__":
    main()
```

- 失败时抛出 **`AssertionError`**。可以故意把实现改坏验证：
- 本质上，这是解释器告诉我们某个条件没有满足。

```python
# calculator.py (bug)
def square(n):
    return n + n  # 应为 n * n
```

- 也可穷举多用例（但依旧繁琐）：见多个 `try/except AssertionError` 的示例。
```python
from calculator import square


def main():
    test_square()


def test_square():
    try:
        assert square(2) == 4
    except AssertionError:
        print("2 squared is not 4")
    try:
        assert square(3) == 9
    except AssertionError:
        print("3 squared is not 9")
    try:
        assert square(-2) == 4
    except AssertionError:
        print("-2 squared is not 4")
    try:
        assert square(-3) == 9
    except AssertionError:
        print("-3 squared is not 9")
    try:
        assert square(0) == 0
    except AssertionError:
        print("0 squared is not 0")


if __name__ == "__main__":
    main()
```
- 上面的代码说明了一个重大挑战：我们如何才能更轻松地测试您的代码，而无需像上面那样编写几十行代码？
- 您可以在 Python 的 assert 文档中了解更多信息。(https://docs.python.org/3/reference/simple_stmts.html#assert)

<mark>要点：</mark>我们需要**测试运行器**来收集并美观展示结果。


---

## `pytest` 框架

- 安装：`pip install pytest`。
- pytest 是一个第三方库，允许你对程序进行单元测试。也就是说，你可以在程序内部测试函数。
- 要使用 pytest ，请在控制台窗口中输入 pip install pytest。
- 把测试拆分为**多个函数**：

```python
# test_calculator.py
from calculator import square

def test_square():
    assert square(2) == 4
    assert square(3) == 9
    assert square(-2) == 4
    assert square(-3) == 9
    assert square(0) == 0
```

运行：`pytest test_calculator.py`。实现有误，会显示失败，有效实现，会全部通过。

- 在终端窗口中输入 pytest test_calculator.py 。您会立即注意到输出已提供。请注意输出顶部附近的红色 F ，它表示代码中某些内容失败了。此外，请注意红色 E 提供了一些有关 calculator.py 程序中错误的提示。根据输出，您可以想象一个场景，其中 3 * 3 输出的是 6 而不是 9。



- 为了改进我们的测试代码，让我们修改 test_calculator.py ，将代码分成不同的测试组：
- 分组：

```python
from calculator import square

def test_positive():
    assert square(2) == 4
    assert square(3) == 9

def test_negative():
    assert square(-2) == 4
    assert square(-3) == 9

def test_zero():
    assert square(0) == 0
```

- 断言**抛出异常**：
- 请注意，我们将相同的五个测试拆分成了三个不同的函数。像 pytest 这样的测试框架会运行每个函数，即使其中一个函数失败。重新运行 pytest test_calculator.py ，你会注意到显示了更多错误。更多的错误输出让你能够进一步探究代码中可能存在问题的原因。

```python
import pytest
from calculator import square

def test_str():
    with pytest.raises(TypeError):
        square("cat")
```
- 注意，我们没有使用 assert ，而是利用了 pytest 库中一个名为 raises 的函数，该函数允许你表达你期望引发的错误。我们需要在程序顶部添加 import pytest ，然后使用我们期望的错误类型调用 pytest.raises 。
- 总而言之，作为一名程序员，您可以根据需要定义尽可能多的测试条件！

<mark>技巧：</mark>函数名以 `test_` 开头；`pytest` 会运行**所有**测试函数。
- 您可以在 Pytest 的 pytest 文档中了解更多信息。 (https://docs.pytest.org/en/7.1.x/getting-started.html)

---

## 测试字符串

- 看看这段代码，你觉得这种测试方法有效吗？为什么这个测试可能无效？注意， hello.py 中的 hello 函数打印了一些内容：也就是说，它没有返回值！
  

- 先看原始版本：`hello.py` 的 `hello` 是 `print`，不便测试。**改为返回值**：

```python
# hello.py
def main():
    name = input("What's your name? ")
    print(hello(name))

def hello(to="world"):
    return f"hello, {to}"
```

- 注意，我们将 hello 函数修改为返回字符串。这意味着我们现在可以使用 pytest 来测试 hello 函数了。


- 与本课中之前的测试用例一样，我们可以单独进行测试：
- 测试：

```python
# test_hello.py
from hello import hello

def test_default():
    assert hello() == "hello, world"

def test_argument():
    assert hello("David") == "hello, David"
```

<mark>模式：</mark>**纯函数（返回值）** 比只打印的函数更易测试。

---

## 按文件夹目录组织测试

- 使用多个测试的单元测试代码非常常见，因此您可以使用单个命令运行整个测试文件夹。

```bash
mkdir test
code test/test_hello.py
```

`test/test_hello.py`：

```python
from hello import hello

def test_default():
    assert hello() == "hello, world"

def test_argument():
    assert hello("David") == "hello, David"
```
- 如果没有专门的 __init__ 文件， pytest 不允许我们仅凭此文件（或一整套文件）以文件夹形式运行测试。在终端窗口中，输入 code test/__init__.py 来创建此文件。注意 test/ 和之前的一样，以及 init 两侧的双下划线。即使这个 __init__.py 文件为空， pytest 也会收到提示，包含 __init__.py 的整个文件夹都有可以运行的测试。
  
- 新建（可为空）`test/__init__.py`。 
- 现在，在终端中输入 pytest test ，您可以运行整个 test 文件夹的代码。

<mark>约定：</mark>文件名 `test_*.py`，函数以 `test_` 开头。
您可以在 Pytest 的导入机制文档中了解更多信息。 （https://docs.pytest.org/en/7.1.x/explanation/pythonpath.html?highlight=folder#pytest-import-mechanisms-and-sys-path-pythonpath）
---

## 小结

测试代码是编程过程中自然而然的一部分。单元测试允许您测试代码的特定方面。您可以创建自己的程序来测试代码。或者，您可以使用像 pytest 这样的框架来运行单元测试。在本讲座中，您学习了……
- *单元测试* 思想
- **`assert`** 断言
- **`pytest`**：发现、分组、报告
- 测试字符串：把 `print` 改为 **返回值**
- 用 **目录 文件夹** 组织测试与 `__init__.py`
