# 讲义 6 — 文件读写、CSV、二进制文件与 PIL

## 目录
- [文件 I/O](#文件-io)
- [`open`](#open-1)
- [`with` 上下文管理器](#with-上下文管理器)
- [CSV](#csv-1)
- [二进制文件与 PIL](#二进制文件与-pil)
- [小结](#小结)

---

## 文件 I/O

- 之前所有数据都只在*内存*中；程序结束后就丢失。<mark>文件 I/O</mark> 让我们把数据**写入**文件或从文件**读取**。
- 收集并排序姓名：

```python
names = []
for _ in range(3):
    names.append(input("What's your name? "))

for name in sorted(names):
    print(f"hello, {name}")
```

<mark>提醒：</mark>这仍然是内存中的列表；请注意，一旦执行此程序，所有信息都将丢失。文件 I/O 允许您的程序存储这些信息，以便以后使用。需要把姓名保存到磁盘。

- 您可以在 Python 的 sorted 文档中了解更多信息。（https://docs.python.org/3/library/functions.html#sorted）
---

## `open`

- **`open`** 打开文件并指定模式：`"w"` 覆盖写，`"a"` 追加写，`"r"` 只读。

覆盖写：

```python
name = input("What's your name? ")
file = open("names.txt", "w")
file.write(name)
file.close()
```

- 请注意， open 函数打开了一个名为 names.txt 的文件，并启用了写入功能，正如 w 所示。上面的代码将打开的文件赋值给一个名为 file 的变量。 file.write(name) 这行将 name 写入文本文件。之后的一行关闭了该文件。

- 通过输入 python names.py 来测试你的代码，你可以输入一个名称，它会保存到文本文件中。但是，如果你使用不同的名称多次运行你的程序，你会注意到，该程序每次都会完全重写 names.txt 文件。


- 理想情况下，我们希望能够将每个名字附加到文件中。在终端窗口中输入 rm names.txt 删除现有文本文件。然后，按如下方式修改代码：

追加并换行：

```python
name = input("What's your name? ")
file = open("names.txt", "a")
file.write(f"{name}\n")
file.close()
```
- 请注意，代码中唯一的变化是将“append”的 w 改为了 a 。
- 多次运行程序后，检查文本文件，你会发现名称连在一起。名称的添加没有任何间隔。
- 请注意， file.write 行已被修改，在每个名称的末尾添加了换行符。

<mark>常见错误：</mark>忘记 `close()`。 
- 您可以在 Python 的 open 文档中了解更多信息。（https://docs.python.org/3/library/functions.html#open）
---

## `with` 上下文管理器

- 使用 **`with`** 自动关闭文件；读取并去掉行末换行：

```python
with open("names.txt", "r") as file:
    lines = file.readlines()

for line in lines:
    print("hello,", line.rstrip())
```
- 请注意，下面的行是缩进 with 。
- 如果我们想从文件中读取数据怎么办？ r
- 注意， readlines 有一个特殊功能，可以读取文件的所有行，并将它们存储在一个名为 lines 的列表中。运行程序，你会发现输出结果相当丑陋。似乎有多个换行符，而实际上应该只有一个。
- 请注意， rstrip 具有删除每行末尾多余的换行符的效果。

- 不过，这段代码还可以进一步简化：
```python
with open("names.txt", "r") as file:
    for line in file:
        print("hello,", line.rstrip())
```
- 但是，请注意，我们没有对名称进行排序。


排序输出：

```python
names = []
with open("names.txt", "r") as file:
    for line in file:
        names.append(line.rstrip())

for name in sorted(names):
    print(f"hello, {name}")
```
- 注意， names 是一个空白列表，我们可以在其中收集名称。每个名称都会被添加到内存中的 names 列表中。然后，内存中排序列表中的每个名称都会被打印出来。运行代码，你会看到名称现在已正确排序。
- 如果我们想要存储的不仅仅是学生姓名，该怎么办？如果我们想同时存储学生姓名和他们的住址，该怎么办？

---

## CSV

- **CSV** 是“逗号分隔值”文本格式。
  
```
在终端窗口中，输入 code students.csv 。确保新的 CSV 文件如下所示：
Hermione,Gryffindor
Harry,Gryffindor
Ron,Gryffindor
Draco,Slytherin
```

基础读取：
```python
with open("students.csv") as file:
    for line in file:
        row = line.rstrip().split(",")
        print(f"{row[0]} is in {row[1]}")
```
- 请注意， rstrip 删除了 CSV 文件中每一行的末尾。split 告诉解释 split 在 CSV 文件中哪里可以找到每个值的末尾。row row[0] 是 CSV 文件中每一行的第一个元素。row row[1] 是 CSV 文件中每一行的第二个元素。


- Python 内置了一些功能，可以进一步简化这段代码。请按如下方式修改您的代码：
```python
with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        print(f"{name} is in {house}")
```
- 注意 split 函数实际上返回两个值：逗号前的值和逗号后的值。因此，我们可以依靠该功能一次赋值两个变量，而不是一个！

想象一下，我们再次想提供这个列表作为排序输出？您可以按如下方式修改代码：
```python
students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        students.append(f"{name} is in {house}")

for student in sorted(students):
    print(student)
```
- 注意，我们创建了一个名为 students 的 list 。我们将每个字符串 append 到此列表中。然后，我们输出列表的排序版本。

Python 允许 dictionaries 将键与值关联起来。这段代码可以进一步改进：
```python
students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        student = {}
        student["name"] = name
        student["house"] = house
        students.append(student)

for student in students:
    print(f"{student['name']} is in {student['house']}")
```
- 注意，我们创建了一个名为 student 的空字典。我们将每个学生的值（包括他们的姓名和学院）添加到 student 字典中。然后，我们将该学生添加到名为 students list 中。

- 我们可以改进代码来说明这一点，如下所示：
```python
students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        student = {"name": name, "house": house}
        students.append(student)

for student in students:
    print(f"{student['name']} is in {student['house']}")
```
- 请注意，这会产生所需的结果，但没有对学生进行排序。
- 不幸的是，我们无法像之前那样对学生进行排序，因为现在每个学生都是一个列表内的字典。如果 Python 能够对 students student 列表进行排序，并根据学生姓名对字典列表进行排序，那就太好了。

为了在我们的代码中实现这一点，请进行以下更改：
```python
students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        students.append({"name": name, "house": house})


def get_name(student):
    return student["name"]


for student in sorted(students, key=get_name):
    print(f"{student['name']} is in {student['house']}")
```

- 注意， sorted 需要知道如何获取每个学生的键。Python 允许使用一个名为 key 的参数，我们可以用它来定义学生列表将基于哪个“键”进行排序。因此， get_name 函数只返回 student["name"] 的键。运行此程序，您将看到列表现在已按姓名排序。


- 不过，我们的代码还可以进一步改进。如果你只打算使用一次像 get_name 这样的函数，你可以按照下面介绍的方式简化代码。修改代码如下：

收集为字典，并**按姓名排序**：

```python
students = []
with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        students.append({"name": name, "house": house})

for s in sorted(students, key=lambda s: s["name"]):
    print(f"{s['name']} is in {s['house']}")
```
- 注意我们如何使用 lambda 函数（一个匿名函数），它表示“嘿 Python，这是一个没有名字的函数：给定一个 student ，访问他们的 name 并将其返回给 key 。
  

不幸的是，我们的代码有点脆弱。假设我们修改了 CSV 文件，标明了每个学生的成长地点。这会对我们的程序产生什么影响？首先，修改 students.csv 文件，如下所示：
  
```
Harry,"Number Four, Privet Drive"
Ron,The Burrow
Draco,Malfoy Manor
```

- 解释器产生的 ValueError: too many values to unpack 错误是因为我们之前编写这个程序时假设 CSV 文件是用 , （逗号） split 。我们可以花更多时间解决这个问题，但确实有人已经开发出了一种“解析”（也就是读取）CSV 文件的方法！
  
- Python 内置的 csv 库带有一个名为 reader 的对象。顾名思义，尽管“Number Four, Privet Drive”中多了一个逗号， reader 仍然可以使用 reader 来读取 CSV 文件。reader 以 for 循环的形式工作，每次迭代都会从 CSV 文件中 reader 一行数据。这一行本身是一个列表，列表中的每个值都对应着该行中的一个元素。例如， row[0] 是给定行的第一个元素，而 row[1] 是第二个元素。
  
- <mark>更健壮做法：</mark>使用 `csv` 标准库处理包含逗号等复杂情况。



`csv.reader`：

```python
import csv

students = []
with open("students.csv") as file:
    reader = csv.reader(file)
    for row in reader:
        students.append({"name": row[0], "home": row[1]})

for student in sorted(students, key=lambda student: student["name"]):
    print(f"{student['name']} is from {student['home']}")
```

到目前为止，我们一直依赖程序来具体确定 CSV 文件中哪些部分是姓名，哪些部分是房屋信息。不过，更好的设计是直接将其嵌入到 CSV 文件中，如下所示：
```
name,home
Harry,"Number Four, Privet Drive"
Ron,The Burrow
Draco,Malfoy Manor
```
- 请注意，我们在 CSV 文件中明确指出，任何读取它的内容都应该期望每行都有一个名称值和一个主页值。

我们可以修改我们的代码以使用 csv 库的一部分（称为 DictReader 来更灵活地处理我们的 CSV 文件：

`csv.DictReader`（需要文件首行有 `name,home` 头部）：

```python
import csv

students = []
with open("students.csv") as file:
    reader = csv.DictReader(file)
    for row in reader:
        students.append({"name": row["name"], "home": row["home"]})
        
for student in sorted(students, key=lambda student: student["name"]):
    print(f"{student['name']} is in {student['home']}")
```
- 请注意，我们用 DictReader 替换了 reader ，它一次返回一个字典。另外，请注意，解释器将直接访问 row 字典，获取每个学生的 name 和 home 。这是一个防御性编码的示例。只要设计 CSV 文件的人在第一行输入了正确的标题信息，我们就可以使用我们的程序访问该信息。



到目前为止，我们一直在读取 CSV 文件。如果我们想写入 CSV 文件该怎么办？

写入 CSV：

```python
import csv

name = input("What's your name? ")
home = input("Where's your home? ")

with open("students.csv", "a", newline="") as file:
    writer = csv.DictWriter(file, fieldnames=["name", "home"])
    writer.writerow({"name": name, "home": home})
```
- 注意我们如何利用 DictWriter 的内置功能，它接受两个参数：要写入的 file 和要写入的 fieldnames 。此外，请注意 writerow 函数如何接受一个字典作为参数。确切地说，我们告诉解释器写入一行，其中包含两个字段，分别为 name 和 home 。


- 请注意，您可以读取和写入多种类型的文件。
- 您可以在 Python 的 CSV 文档中了解更多信息。https://docs.python.org/3/library/csv.html
---

## 二进制文件与 PIL

- 二进制文件以字节保存数据（图片/音频/视频等）。 我们今天要讨论的另一种文件类型是二进制文件。二进制文件只是由 1 和 0 组成的集合。这种类型的文件可以存储任何内容，包括音乐和图像数据。
  
- 有一个流行的 Python 库叫做 PIL ，可以很好地处理图像文件。 
  
- 使用 **Pillow (PIL)** 合成动图 GIF：

```python
# pip install pillow
import sys
from PIL import Image

images = []
for arg in sys.argv[1:]:
    images.append(Image.open(arg))

images[0].save(
    "costumes.gif",
    save_all=True,
    append_images=images[1:],
    duration=200,
    loop=0,
)
```
- 请注意，我们从 PIL 导入了 Image 功能。请注意，第一个 for 循环只是循环遍历作为命令行参数提供的图像，并将主题存储到名为 images 的 list 中。1 1: 从第二个元素开始对 argv 进行切片。最后几行代码保存了第一张图片，并在其后附加了第二张图片，从而创建了一个 GIF 动图。在终端中输入 python costumes.py costume1.gif costume2.gif 。现在，在终端窗口中输入 code costumes.gif ，您现在就可以看到一个 GIF 动图了。
运行：`python costumes.py costume1.gif costume2.gif`。

<mark>参数说明：</mark>`save_all=True` 保存为动图；`duration` 每帧毫秒；`loop=0` 无限循环。
- 您可以在 Pillow 的 PIL 文档中了解更多信息。https://pillow.readthedocs.io/
---

## 小结

现在，我们不仅了解了如何以文本形式读写文件，还能使用 1 和 0 读写文件。我们迫不及待地想看看您接下来会如何运用这些新功能。

你已经掌握：

- **文件 I/O** 的读写流程
- **`open`** 的常用模式与风险
- 使用 **`with`** 自动关闭文件
- 利用 **`csv`** 模块稳健地读写 CSV（`reader`、`DictReader`、`DictWriter`）
- 处理**二进制文件**并用 **PIL** 生成 GIF
